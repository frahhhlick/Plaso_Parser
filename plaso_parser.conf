input {
  file {
    path => "${TIMELINE_PATH}/*.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
  }
}

filter {
  mutate {
    gsub => [
      "message", "\"", "",
      "message", "'", "",
      "[event][original]", "\"", "",
      "[event][original]", "'", ""
    ]
  }

  csv {
    separator => ","
    columns => [
      "[event][date]",
      "[event][time]",
      "[event][timezone]",
      "[event][macb]",
      "[event][source]",
      "[event][source_type]",
      "[event][type]",
      "[event][user]",
      "[event][host]",
      "[event][desc][short]",
      "[event][desc][long]",
      "[event][version]",
      "[event][source_file]",
      "[event][inode]",
      "[event][notes]",
      "[event][format]",
      "[event][extra]"
    ]
  }

  date {
    match => ["[event][time]", "ISO8601"]
  }

  ## Chrome History
  if [event][source_type] == "Chrome History" {
    grok {
      match => {
        "[event][desc][long]" =>
          "%{DATA:[event][url]} \\[count: \\d\\] Visit from: %{DATA:[event][referrer]}\\sVisit count: %{NUMBER:[event][visit_count]} Type: %{GREEDYDATA:[event][visit_type]}"
      }
    }
  }

  if [event][source_type] == "Chrome History" and "_grokparsefailure" in [tags] {
    grok {
      match => {
        "[event][desc][long]" =>
          "%{DATA:[event][url]} \\[count: \\d\\] Visit from:\\s+Visit count: %{NUMBER:[event][visit_count]} Type: %{GREEDYDATA:[event][visit_type]}"
      }
    }
  }

  ## Firefox History
  if [event][source_type] == "Firefox History" {
    grok {
      match => {
        "[event][desc][long]" =>
          "%{DATA:[event][url]} \\[count: \\d\\] Host: %{DATA:[event][domain]} visited from: %{GREEDYDATA:[event][referrer]} Transition: %{GREEDYDATA:[event][transition]}"
      }
    }
  }

  ## MSIE WebCache
  if [event][source_type] in [
    "MSIE WebCache container record",
    "MSIE WebCache containers record"
  ] {    
    grok {
      match => {
        "[event][desc][long]" =>
          "URL: Visited: %{DATA:[event][url]} Access count: %{NUMBER:[event][visit_count]} Synchronization count: %{NUMBER:[event][synch_count]} Cached file size: %{NUMBER:[event][cache_file_size]} Entry identifier: %{NUMBER:[event][entry_id]} Container identifier: %{NUMBER:[event][container_id]} Cache identifier: %{NUMBER:[event][cache_id]}"
      }
    }
  }
  if [event][source_type] in [
    "MSIE WebCache container record",
    "MSIE WebCache containers record"
  ] and "_grokparsefailure" in [tags] {
    grok {
      match => {
        "[event][desc][long]" =>
        "URL:\s+:%{NUMBER}: %{DATA:[event][url]} Access count: %{NUMBER:[event][visit_count]} Synchronization count: %{NUMBER:[event][synch_count]} Cached file size: %{NUMBER:[event][cache_file_size]} Entry identifier: %{NUMBER:[event][entry_id]} Container identifier: %{NUMBER:[event][container_id]} Cache identifier: %{NUMBER:[event][cache_id]}"
      }
    }
  }


  if [event][source_type] in [
    "MSIE WebCache container record",
    "MSIE WebCache containers record"
  ] and "_grokparsefailure" in [tags] {
    grok {
      match => {
        "[event][desc][long]" =>
          "URL: %{DATA:[event][url]} Access count: %{NUMBER:[event][visit_count]} Synchronization count: %{NUMBER:[event][synch_count]} Filename: %{DATA:[event][filename]} Cached file size: %{NUMBER:[event][cache_file_size]} Response headers: %{GREEDYDATA:[event][headers]} Entry identifier: %{NUMBER:[event][entry_id]} Container identifier: %{NUMBER:[event][container_id]} Cache identifier: %{NUMBER:[event][cache_id]}"
      }
    }
  }

  if [event][source_type] in [
    "MSIE WebCache container record",
    "MSIE WebCache containers record"
  ] and "_grokparsefailure" in [tags] {
    grok {
      match => {
        "[event][desc][long]" =>
          "URL: %{DATA:[event][url]} Access count: %{NUMBER:[event][visit_count]} Synchronization count: %{NUMBER:[event][synch_count]} Filename: %{DATA:[event][filename]} Cached file size: %{NUMBER:[event][cache_file_size]} Request headers: %{DATA:[event][req_headers]} Response headers: %{GREEDYDATA:[event][res_headers]} Entry identifier: %{NUMBER:[event][entry_id]} Container identifier: %{NUMBER:[event][container_id]} Cache identifier: %{NUMBER:[event][cache_id]}"
      }
    }
  mutate {
    remove_tag => ["_grokparsefailure"]
  }
 }

if [event][url] and ![event][domain] {
  grok {
    match => { "[event][url]" => "%{URIPROTO}://%{DATA:[event][host]}/" }
  }
}

  ## AppCompatCache
  if [event][source_type] == "AppCompatCache Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] Cached entry: %{NUMBER:[event][entry_number]} Path: %{GREEDYDATA:[event][path]}"
      }
    }
  }

  ## BAM Registry Key
  if [event][source_type] == "Background Activity Moderator Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "%{DATA:[event][path]} \[%{DATA:[event][sid]}\]"
      }
    }
  }


  ## Registry
  if [event][source_type] == "Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
          "^\\[%{DATA:[event][registry_key]}\\]\\s*%{GREEDYDATA:[event][registry_change]}"
      }
    }
  }

  ## RDP Registry
  if [event][source_type] == "RDP Connection Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] Username hint: (%{DATA:[event][user_domain]}\\)(%{DATA:[event][user]})"
      }
    }
}

  ## PE
  if [event][source_type] == "PE/COFF file" {
    grok {
      match => {
        "[event][desc][long]" => "^\[%{DATA:[event][registry_key]}\] DriveLetter: %{DATA:[event][drive_letter]} RemoteServer: %{DATA:[event][share_server]} ShareName: %{DATA:[event][share_name]} Type: %{GREEDYDATA:[event][share_type]}"

      }
    }
  }


  ## Network Registry Keys
  if [event][source_type] == "Network Drive Registry Key" {
    grok {
      match => {
        "[event][desc][long]" => "^\[%{DATA:[event][registry_key]}\] DriveLetter: %{DATA:[event][drive_letter]} RemoteServer: %{DATA:[event][share_server]} ShareName: %{DATA:[event][share_name]} Type: %{GREEDYDATA:[event][share_type]}"
        
      }
    }
  }

  ## Shellbags
  if [event][source_type] == "BagMRU Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "%{DATA} _event_values_hash: %{DATA:[event][hash]} %{DATA} key_path: %{DATA:[event][registry_key]} last_written_time: %{GREEDYDATA:[event][last_written_time]}"
      }
    }
  }

  if [event][source_type] == "BagMRU Registry Key" and "_grokparsefailure" in [tags] {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] %{DATA} Shell item path: %{GREEDYDATA:[event][path]}"
      }
    }
  mutate {
    remove_tag => ["_grokparsefailure"]
    }
  }

  if [event][source_type] == "MRUList Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] %{DATA} \[MRU Value a\]: %{GREEDYDATA:[event][executables]}"
      }
    }
  mutate {
    remove_tag => ["_grokparsefailure"]
    }
  }
  if [event][source_type] == "MRUListEx Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] %{DATA} \[MRU Value \d]: %{GREEDYDATA:[event][executables]}"
      }
    }
  }

  ## OLECF 
  if [event][source_type] == "OLECF Dest list entry" {
    grok {
      match => {
        "[event][desc][long]" =>
        "%{DATA} Path: %{DATA:[event][path]} Droid"
      }
    }
  }

  ## PS Transcript
  if [event][source_type] == "PowerShell Transcript Event" {
    grok {
      match => {
        "[event][desc][long]" =>
        "%{GREEDYDATA:[event][commands]} as user (%{DATA:[event][user_domain]}\\)%{DATA:[event][user]} in process %{NUMBER:[event][pid]}"
      }
    }
  }

 
  ## AMCACHE
  if [event][source_type] == "Amcache Registry Entry" {
    grok {
      match => {
        "[event][desc][long]" =>
        "path: %{WINPATH:[event][path]} product_name: %{DATA:[event][product_name]} company_name: %{DATA:[event][company_name]} file_version: %{DATA:[event][file_version]} file_size: %{DATA:[event][file_size]} program_identifier: %{GREEDYDATA:[event][program_id]}"
      }
    }  
  }  

  ## RECYCLE BIN
  if [event][source_type] == "Recycle Bin" {
    grok {
      match => {
        "[event][desc][long]" =>
        "%{GREEDYDATA:[event][filename]}"
      }
    }  
  }  


## DATA CLEANUP
 # if "\\" in [event][user] {
 #   mutate {
 #     gsub => [
 #   "[event][user]", "^.*\\\\", ""
 # ]
 # }
 #}
}

output {
  if [event][source_type] == "Recycle Bin" {
    stdout {
      codec => rubydebug
    }
  }
}
