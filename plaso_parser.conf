input {
  file {
    path => "${TIMELINE_PATH}/*.csv"
    start_position => "beginning"
    sincedb_path => "/dev/null"
  }
}

filter {
  mutate {
    gsub => [
      "message", "\"", "",
      "message", "'", "",
      "[event][original]", "\"", "",
      "[event][original]", "'", ""
    ]
  }

  csv {
    separator => ","
    columns => [
      "[event][date]",
      "[event][time]",
      "[event][timezone]",
      "[event][macb]",
      "[event][source]",
      "[event][source_type]",
      "[event][type]",
      "[event][user]",
      "[event][host]",
      "[event][desc][short]",
      "[event][desc][long]",
      "[event][version]",
      "[event][source_file]",
      "[event][inode]",
      "[event][notes]",
      "[event][format]",
      "[event][extra]"
    ]
  }

  if [event][user] == "-" {
  mutate {
    remove_field => ["[event][user]"]
      }
    }

  ## BODYFILE
  if [event][source_type] == "Bodyfile" {
    grok {
      match => {
        "[event][desc][long]" =>
          "%{DATA:[event][path]} Owner"
      }
    }
  }

  ## Chrome History
  if [event][source_type] == "Chrome History" {
    grok {
      match => {
        "[event][desc][long]" =>
          "%{DATA:[event][url]} \[count: \d\] Visit from: %{DATA:[event][referrer]}\sVisit count: %{NUMBER:[event][visit_count]} Type: %{GREEDYDATA:[event][visit_type]}"
      }
    }
  }

  if [event][source_type] == "Chrome History" and "_grokparsefailure" in [tags] {
    grok {
      match => {
        "[event][desc][long]" =>
          "%{DATA:[event][url]} \[count: \d\] Visit from:\s+Visit count: %{NUMBER:[event][visit_count]} Type: %{GREEDYDATA:[event][visit_type]}"
      }
    }
  }
   
  if [event][source_type] == "Chrome History" and "_grokparsefailure" in [tags] {
    grok {
      match => {
        "[event][desc][long]" =>
          "%{DATA:[event][url]} \(%{DATA:[event][path]}\). %{GREEDYDATA}"
      }
    }
  }

  ## Firefox History
  if [event][source_type] == "Firefox History" {
    grok {
      match => {
        "[event][desc][long]" =>
          "%{DATA:[event][url]} \[count: \d\] Host: %{DATA:[event][domain]} visited from: %{GREEDYDATA:[event][referrer]} Transition: %{GREEDYDATA:[event][transition]}"
      }
    }
  }

  ## MSIE WebCache
  if [event][source_type] in [
    "MSIE WebCache container record",
    "MSIE WebCache containers record"
  ] {    
    grok {
      match => {
        "[event][desc][long]" =>
          "URL: Visited: %{DATA:[event][url]} Access count: %{NUMBER:[event][visit_count]} Synchronization count: %{NUMBER:[event][synch_count]} Cached file size: %{NUMBER:[event][cache_file_size]} Entry identifier: %{NUMBER:[event][entry_id]} Container identifier: %{NUMBER:[event][container_id]} Cache identifier: %{NUMBER:[event][cache_id]}"
      }
    }
  }
  if [event][source_type] in [
    "MSIE WebCache container record",
    "MSIE WebCache containers record"
  ] and "_grokparsefailure" in [tags] {
    grok {
      match => {
        "[event][desc][long]" =>
        "URL:\s+:%{NUMBER}: %{DATA:[event][url]} Access count: %{NUMBER:[event][visit_count]} Synchronization count: %{NUMBER:[event][synch_count]} Cached file size: %{NUMBER:[event][cache_file_size]} Entry identifier: %{NUMBER:[event][entry_id]} Container identifier: %{NUMBER:[event][container_id]} Cache identifier: %{NUMBER:[event][cache_id]}"
      }
    }
  }


  if [event][source_type] in [
    "MSIE WebCache container record",
    "MSIE WebCache containers record"
  ] and "_grokparsefailure" in [tags] {
    grok {
      match => {
        "[event][desc][long]" =>
          "URL: %{DATA:[event][url]} Access count: %{NUMBER:[event][visit_count]} Synchronization count: %{NUMBER:[event][synch_count]} Filename: %{DATA:[event][filename]} Cached file size: %{NUMBER:[event][cache_file_size]} Response headers: %{GREEDYDATA:[event][headers]} Entry identifier: %{NUMBER:[event][entry_id]} Container identifier: %{NUMBER:[event][container_id]} Cache identifier: %{NUMBER:[event][cache_id]}"
      }
    }
  }

  if [event][source_type] in [
    "MSIE WebCache container record",
    "MSIE WebCache containers record"
  ] and "_grokparsefailure" in [tags] {
    grok {
      match => {
        "[event][desc][long]" =>
          "URL: %{DATA:[event][url]} Access count: %{NUMBER:[event][visit_count]} Synchronization count: %{NUMBER:[event][synch_count]} Filename: %{DATA:[event][filename]} Cached file size: %{NUMBER:[event][cache_file_size]} Request headers: %{DATA:[event][req_headers]} Response headers: %{GREEDYDATA:[event][res_headers]} Entry identifier: %{NUMBER:[event][entry_id]} Container identifier: %{NUMBER:[event][container_id]} Cache identifier: %{NUMBER:[event][cache_id]}"
      }
    }
  mutate {
    remove_tag => ["_grokparsefailure"]
  }
 }

if [event][url] and ![event][domain] {
  grok {
    match => { "[event][url]" => "%{URIPROTO}://%{DATA:[event][host]}/" }
  }
}

  ## AppCompatCache
  if [event][source_type] == "AppCompatCache Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] Cached entry: %{NUMBER:[event][entry_number]} Path: %{GREEDYDATA:[event][path]}"
      }
    }
  }

  ## BAM Registry Key
  if [event][source_type] == "Background Activity Moderator Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "%{DATA:[event][path]} \[%{DATA:[event][sid]}\]"
      }
    }
  }


  ## Registry
  if [event][source_type] == "Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
          "^\[%{DATA:[event][registry_key]}\]\s*%{GREEDYDATA}"
      }
    }
  }

  ## RDP Registry
  if [event][source_type] == "RDP Connection Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] Username hint: %{GREEDYDATA:[event][user]}"
      }
    }
}

  ## Run Keys
  if [event][source_type] == "Run/Run Once Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] Entries: \[%{DATA:[event][registry_entries]}\]"
      }
    }
  mutate {
    split => { "[event][registry_entries]" => ":" }
  }
}

  ## PE
  if [event][source_type] == "PE/COFF file" {
    grok {
      match => {
        "[event][desc][long]" => "%{DATA} Export DLL name: %{GREEDYDATA:[event][filename]}"

      }
    }
  }


  ## Network Registry Keys
  if [event][source_type] == "Network Drive Registry Key" {
    grok {
      match => {
        "[event][desc][long]" => "^\[%{DATA:[event][registry_key]}\] DriveLetter: %{DATA:[event][drive_letter]} RemoteServer: %{DATA:[event][share_server]} ShareName: %{DATA:[event][share_name]} Type: %{GREEDYDATA:[event][share_type]}"
      }
    }
  }

  ## SERVICE/DRIVER REG KEY
  if [event][source_type] == "Service/Driver Configuration Registry Key" {
    grok {
      match => {
        "[event][desc][long]" => "^\[%{DATA:[event][registry_key]}\] Type: %{DATA:[event][registry_key_type]} Start: %{DATA:[event][registry_key_start_type]} Image path: %{DATA:[event][path]} Error control: %{DATA}:\s%{GREEDYDATA:[event][registry_values]}"
        
      }
    }
  }

  ## Shellbags
  if [event][source_type] == "BagMRU Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "%{DATA} _event_values_hash: %{DATA:[event][hash]} %{DATA} key_path: %{DATA:[event][registry_key]} last_written_time: %{GREEDYDATA:[event][last_written_time]}"
      }
    }
  }

  if [event][source_type] == "BagMRU Registry Key" and "_grokparsefailure" in [tags] {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] %{DATA} Shell item path: %{GREEDYDATA:[event][path]}"
      }
    }
  mutate {
    remove_tag => ["_grokparsefailure"]
    }
  }

  if [event][source_type] == "MRUList Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] %{DATA} \[MRU Value a\]: %{GREEDYDATA:[event][executables]}"
      }
    }
  mutate {
    remove_tag => ["_grokparsefailure"]
    }
  }
  if [event][source_type] == "MRUListEx Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] %{DATA} \[MRU Value \d]: %{GREEDYDATA:[event][executables]}"
      }
    }
  }

  ## TASK REGISTRY KEYS
  if [event][source_type] == "Task Cache Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] Task: %{DATA:[event][task]} \[Identifier: %{GREEDYDATA:[event][task_id]}\]"
      }
    }
  }

  ## OLECF 
  if [event][source_type] == "OLECF Dest list entry" {
    grok {
      match => {
        "[event][desc][long]" =>
        "%{DATA} Path: %{DATA:[event][path]} Droid"
      }
    }
  }
  
  ## OLECF 
  if [event][source_type] == "Open XML Metadata" {
    grok {
      match => {
        "[event][desc][long]" =>
        "Application: %{DATA:[event][application]} Last saved by: %{DATA:[event][file_author]} Author: %{GREEDYDATA}"
      }
    }
    grok {
      match => {
        "[path]" =>
        "%{GREEDYDATA:[event][filename]}"
      }
    }
  }

  ## PS Transcript
  if [event][source_type] == "PowerShell Transcript Event" {
    grok {
      match => {
        "[event][desc][long]" =>
        "%{GREEDYDATA:[event][commands]} as user (%{DATA:[event][user_domain]}\\)%{DATA:[event][user]} in process %{NUMBER:[event][pid]}"
      }
    }
  }

 
  ## AMCACHE
  if [event][source_type] == "Amcache Registry Entry" {
    grok {
      match => {
        "[event][desc][long]" =>
        "path: %{WINPATH:[event][path]} product_name: %{DATA:[event][product_name]} company_name: %{DATA:[event][company_name]} file_version: %{DATA:[event][file_version]} file_size: %{DATA:[event][file_size]} program_identifier: %{GREEDYDATA:[event][program_id]}"
      }
    }  
  }  

  ## FILE SHELL ENTRY
  if [event][source_type] == "File entry shell item" {
    grok {
      match => {
        "[event][desc][long]" =>
        "%{DATA} Long name: %{DATA:[event][filename]} NTFS %{DATA} Shell item path: <My Computer> %{DATA:[event][path]} Origin: %{GREEDYDATA:[event][file_origin]}"
      }
    }  
  } 

  ## RECYCLE BIN
  if [event][source_type] == "Recycle Bin" {
    grok {
      match => {
        "[event][desc][long]" =>
        "%{GREEDYDATA:[event][filename]}"
      }
    }  
  }  

  ## SETUP API LOG
  if [event][source_type] == "Setup API Log" {
    grok {
      match => {
        "[event][desc][long]" =>
        "%{DATA:[event][action]} - %{DATA:[event][path]} - %{GREEDYDATA:[event][outcome]}"
      }
    }  
   }
    if [event][source_type] == "Setup API Log" and "_grokparsefailure" in [tags] {
      grok {
        match => {
          "[event][desc][long]" =>
          "%{DATA:[event][action]} - %{GREEDYDATA:[event][outcome]}"
      }
    }  
    mutate {
      remove_tag => ["_grokparsefailure"]
    }
  } 
  
  ## SYSTEM
  if [event][source_type] == "System" {
    grok {
      match => {
        "[event][desc][long]" =>
        "%{DATA} MAC address: %{DATA:[event][mac]} Origin: %{GREEDYDATA:[event][path]}"
      }
    }  
   }

  ## TYPED URL REGISTRY
  if [event][source_type] == "Typed URLs Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] Entries: url1: %{GREEDYDATA:[event][url]}"
      }
    }  
   }

  ## USER ACCOUNT REGISTRY 
  if [event][source_type] == "User Account Information Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] Username: %{USERNAME:[event][user]} Full%{GREEDYDATA}RID: %{NUMBER:[event][user_rid]} Login count: %{NUMBER:[event][user_login_count]}"
      }
    }  
  }
   
  ## USER ACCESS LOGGING
  if [event][source_type] == "User Access Logging ROLE_ACCESS record" {
    grok {
      match => {
        "[event][desc][long]" =>
        "Role name: %{DATA:[event][role]} identifier:"
      }
    }  
  }  
  
  if [event][source_type] == "User Access Logging CLIENTS record" {
    grok {
      match => {
        "[event][desc][long]" =>
        "Account: %{DATA}\\%{DATA:[event][user]} Source IP address: %{DATA:[event][source_ip]} Service %{DATA} Service name: %{DATA:[event][service_name]} Total"
      }
    }  
  }  
   
  ## USERASSIST
  if [event][source_type] == "UserAssist Registry Key" {
    grok {
      match => {
        "[event][desc][long]" =>
        "^\[%{DATA:[event][registry_key]}\] %{GREEDYDATA} Value name: %{DATA:[event][path]} Count:%{GREEDYDATA}"
      }
    }  
  }  

  ## WIN SHORTCUT
  if [event][source_type] == "Windows Shortcut" {
    grok {
      match => {
        "[event][desc][long]" =>
        "File size: %{NUMBER:[event][file_size]} %{GREEDYDATA} Network path: %{DATA:[event][source_path]} Link target: \<%{DATA}\> %{GREEDYDATA:[event][path]}"
      }
    }  
  } 
  
  if [event][source_type] == "Windows Shortcut" and "_grokparsefailure" in [tags] {
    grok {
      match => {
        "[event][desc][long]" =>
        "\[%{DATA:[event][shortcut_type]}\] File size: %{NUMBER:[event][file_size]} %{GREEDYDATA} Local path: %{DATA:[event][source_path]} Relative %{GREEDYDATA}"
      }
    }  
  } 
  
  if [event][source_type] == "Windows Shortcut" and "_grokparsefailure" in [tags] {
    grok {
      match => {
        "[event][desc][long]" =>
        "File size: %{NUMBER:[event][file_size]} %{GREEDYDATA} Network path: %{DATA:[event][source_path]} env location: %{GREEDYDATA:[event][path]}"
      }
    }  
  }
  
  ## WIN PREFETCH
  if [event][source_type] == "WinPrefetch" {
    grok {
      match => {
        "[event][desc][long]" =>
        "Prefetch \[%{DATA:[event][executable]}\] was executed - run count %{NUMBER:[event][run_count]} path hints: %{DATA:[event][path]} %{GREEDYDATA}"
      }
    }  
  } 
  
  ## WINEVTX
  if [event][source_type] == "WinEVTX" {
    grok {
      match => {
        "[event][desc][long]" =>
        "\[%{DATA:[event][code]}\s\/%{DATA}\] %{GREEDYDATA} Source Name: %{DATA:[event][channel]} Strings:"
    }
  }

    grok {
      match => {
        "[event][extra]" => "TargetUserName>%{DATA:[event][user]}<\/Data"
    }
  }

    mutate {
      remove_tag => ["_grokparsefailure"]
  }
}

  if [event][code] == "1149" {
    grok {
      match => {
        "[event][desc][long]" =>
        "Strings: \[%{USERNAME:[event][user]}\s+%{IP:[event][source_ip]}\]"
      }
    }  
  } 
  
  if [event][code] == "5140" {
    grok {
      match => {
        "[event][desc][long]" =>
        "Strings: \[%{DATA}\s+%{USERNAME:[event][user]}\s+%{DATA}\s+%{DATA}\s+%{DATA}\s+%{IP:[event][source_ip]}\s+%{NUMBER}\s+%{DATA:[event][share_name]}\s+"
      }
    }  
  } 
  
    if [event][code] == "22" or [event][code] == "21" {
    grok {
      match => {
        "[event][desc][long]" =>
        "Strings: \[%{DATA}\\%{USERNAME:[event][user]}\s+%{NUMBER}\s+%{IP:[event][source_ip]}"
      }
    }  
  } 
  
## DATA CLEANUP
 # if "\\" in [event][user] {
 #   mutate {
 #     gsub => [
 #   "[event][user]", "^.*\\\\", ""
 # ]
 # }
 #}
 
 ##FILENAME CHECK - if no filename, save event path as filename for easy search
 if ![event][filename] {
  grok {
    match => {       
      "[event][source_file]" =>
      "%{GREEDYDATA:[event][filename]}"
      }
    }  
  }
 
 ##USER CHECK - if no event user, check path for user data and save if present
 
 if ![event][user] {
  grok {
    match => {       
      "[event][path]" =>
      "/Users/%{DATA:[event][user]}/"
      }
    }  
   }
   
 if ![event][user] and "_grokparsefailure" in [tags] {
  grok {
    match => {       
      "[event][source_file]" =>
      "/Users/%{DATA:[event][user]}/"
      }
    }  
    mutate {
      remove_tag => ["_grokparsefailure"]
    }
  }
  mutate {
    remove_field => ["message", "host"]
  }
  
}

output {
    elasticsearch {
      index => "plaso-parsed"
      hosts => localhost
    }
  }
